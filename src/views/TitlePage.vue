<template>
  <el-loading
    :loading="isOptimizing"
    text="æ­£åœ¨ä¼˜åŒ–æ ‡é¢˜ï¼Œè¯·ç¨å€™..."
    fullscreen
  ></el-loading>
  <div class="titlePage">
    <div class="title-generator">
      <el-card class="mt-4" :disabled="!selectedProject">
        <el-divider>é€‰æ‹©é¡¹ç›®</el-divider>
        <el-row>
          <el-col :span="12" style="margin: 0 auto">
            <el-form label-width="100px">
              <el-form-item label="é€‰æ‹©é¡¹ç›®">
                <el-select
                  v-model="selectedProject"
                  @change="handleProjectChange"
                  placeholder="è¯·é€‰æ‹©é¡¹ç›®"
                >
                  <el-option
                    v-for="project in projectList"
                    :key="project.folderName"
                    :label="project.folderName"
                    :value="project.folderName"
                  />
                </el-select>
              </el-form-item>
            </el-form>
          </el-col>
        </el-row>
        <div
          class="header"
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
          "
        >
          <div>ğŸ“¦ å…³é”®è¯è¯åº“åˆ—è¡¨</div>
          <div style="display: flex; gap: 10px; align-items: center">
            <el-button
              type="success"
              :disabled="!selectedProject"
              @click="autoGenerateDialogVisible = true"
              >AI ç”Ÿæˆè¯åº“</el-button
            >
            <el-button
              type="primary"
              :disabled="!selectedProject"
              @click="openAddDialog"
              >æ–°å¢è¯åº“</el-button
            >
            <el-button
              type="danger"
              :disabled="!selectedProject || !selectedLibRows.length"
              @click="batchDeleteLibraries"
              >æ‰¹é‡åˆ é™¤</el-button
            >
            <el-button :disabled="!selectedProject" @click="exportLibraries"
              >å¯¼å‡ºè¯åº“</el-button
            >
            <el-upload
              :disabled="!selectedProject"
              :show-file-list="false"
              accept=".json"
              :auto-upload="false"
              @change="importLibraries"
            >
              <el-button>å¯¼å…¥è¯åº“</el-button>
            </el-upload>
          </div>
        </div>

        <el-table
          :data="wordLibraries"
          border
          @selection-change="(val: any) => (selectedLibRows = val)"
        >
          <el-table-column type="selection" width="40" />
          <el-table-column prop="name" label="è¯åº“åç§°" width="200" />
          <el-table-column label="ä¸­æ–‡å…³é”®è¯">
            <template #default="{ row }">
              <div v-if="row.words">
                <el-tag
                  v-for="(w, i) in row.words"
                  :key="i"
                  type="primary"
                  class="mb-1 mr-1"
                >
                  {{ w.zh }}
                </el-tag>
              </div>
            </template>
          </el-table-column>

          <el-table-column label="è‹±æ–‡å…³é”®è¯">
            <template #default="{ row }">
              <div v-if="row.words">
                <el-tag
                  v-for="(w, i) in row.words"
                  :key="i"
                  type="success"
                  class="mb-1 mr-1"
                >
                  {{ w.en }}
                  <el-icon><CloseBold /></el-icon>
                </el-tag>
              </div>
            </template>
          </el-table-column>
          <el-table-column label="æ“ä½œ" width="160">
            <template #default="{ row, $index }">
              <el-button size="small" @click="editLibrary(row)">ç¼–è¾‘</el-button>
              <el-button
                size="small"
                type="danger"
                @click="removeLibrary($index)"
                >åˆ é™¤</el-button
              >
            </template>
          </el-table-column>
        </el-table>
      </el-card>

      <el-card class="mt-4" :disabled="!selectedProject">
        <template #header>
          <div class="flex justify-between items-center">
            <div class="flex items-center gap-2 font-bold text-base">
              <span style="font-weight: bold">ğŸ”€ ç»„åˆé¡ºåº + å…³é”®è¯å­—æ®µ</span>
            </div>
            <div class="flex items-center gap-2" style="margin-top: 10px">
              <div class="method" style="display: flex; margin-top: 10px">
                <span>ç›®æ ‡æ ‡é¢˜æ•°ï¼š</span>
                <el-input-number
                  v-model="generateCount"
                  :min="1"
                  size="small"
                />
                <div class="connect" style="margin-left: auto">
                  <span style="font-size: 14px; margin-right: 10px"
                    >å…³é”®è¯è¿æ¥ç¬¦:
                  </span>
                  <el-select
                    v-model="keywordJoiner"
                    placeholder="é€‰æ‹©è¿æ¥ç¬¦"
                    size="small"
                    style="width: 200px; margin-right: 10px"
                  >
                    <el-option label="ç©ºæ ¼" value=" " />
                    <el-option label="æ¨ªæ  -" value="-" />
                    <el-option label="é€—å· ," value=", " />
                    <el-option label="æ— è¿æ¥" value="" />
                  </el-select>
                  <el-button
                    type="primary"
                    size="small"
                    @click="titleCombineConfig.push({ libId: -1, field: 'en' })"
                  >
                    <el-icon size="16">
                      <Plus />
                    </el-icon>
                    æ·»åŠ ç»„åˆé¡¹
                  </el-button>
                  <el-button
                    type="success"
                    icon=""
                    size="small"
                    @click="generateTitles"
                  >
                    <el-icon size="16">
                      <MagicStick />
                    </el-icon>
                    ç”Ÿæˆæ ‡é¢˜
                  </el-button>
                </div>
              </div>
            </div>
          </div>
        </template>

        <div
          v-for="(item, index) in titleCombineConfig"
          :key="index"
          class="config-row"
        >
          <el-row :gutter="10" justify="center" align="middle">
            <el-col :span="6">
              <el-select
                v-model="item.libId"
                placeholder="é€‰æ‹©è¯åº“"
                size="small"
                style="width: 100%"
              >
                <el-option
                  v-for="lib in wordLibraries"
                  :key="lib.id"
                  :label="lib.name"
                  :value="lib.id"
                />
              </el-select>
            </el-col>

            <el-col :span="4">
              <el-select
                v-model="item.field"
                placeholder="å…³é”®è¯å­—æ®µ"
                size="small"
                style="width: 100%"
              >
                <el-option label="ä¸­æ–‡" value="zh" />
                <el-option label="è‹±æ–‡" value="en" />
              </el-select>
            </el-col>

            <el-col :span="2">
              <el-button
                type="danger"
                icon
                size="small"
                circle
                @click="titleCombineConfig.splice(index, 1)"
              >
                <el-icon><Delete /></el-icon>
              </el-button>
            </el-col>
          </el-row>
        </div>
      </el-card>

      <el-card class="mt-4">
        <template #header>
          <el-row>
            <el-col :span="5">
              <div class="title">
                ğŸ“¦ å½“å‰é¡¹ç›®æ ‡é¢˜ï¼ˆå…± {{ productTitles.length }} æ¡ï¼‰
              </div>
            </el-col>
            <el-col :span="9">
              <div class="applyRule">
                <el-input-number
                  v-model="pageSize"
                  :min="1"
                  :max="100"
                ></el-input-number>
                <el-radio-group v-model="applyRule">
                  <!-- åº”ç”¨è§„åˆ™ -->
                  <el-tooltip
                    class="box-item"
                    effect="dark"
                    content="ç±»ç›®æŒ‰ç…§é¡ºåºåˆ†é…æ ‡é¢˜,å¦‚: 10ä¸ªç±»ç›®1ä¸ªç±»ç›®1ä¸ªæ ‡é¢˜,å¾ªç¯åˆ†é…"
                    placement="top"
                  >
                    <el-radio value="è½®å¾ªæ¨¡å¼">è½®å¾ªæ¨¡å¼</el-radio>
                  </el-tooltip>
                  <el-tooltip
                    class="box-item"
                    effect="dark"
                    content="æ ‡é¢˜æ•°Ã·ç±»ç›®æ•°å‡åˆ†æ ‡é¢˜,å¦‚: 10ä¸ªç±»ç›®100ä¸ªæ ‡é¢˜,1ä¸ªç±»ç›®10ä¸ªæ ‡é¢˜"
                    placement="top"
                  >
                    <el-radio value="å‡åˆ†æ¨¡å¼">å‡åˆ†æ¨¡å¼</el-radio>
                  </el-tooltip>
                </el-radio-group>
                <el-tooltip
                  class="box-item"
                  effect="dark"
                  content="æ¯ä¸ªç±»ç›®åˆ†é…å¤šå°‘ä¸ªæ ‡é¢˜"
                  placement="right"
                >
                  <el-button
                    type="primary"
                    @click="applyToCategory($event, pageSize)"
                    style="margin-left: 10px"
                    >åº”ç”¨</el-button
                  >
                </el-tooltip>
              </div>
            </el-col>
          </el-row>
          <el-row
            style="
              padding-top: 10px;
              margin-top: 10px;
              border-top: 1px solid #eee;
            "
          >
            <el-col
              :span="24"
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <div
                class="select text-left mb-2"
                style="display: flex; align-items: center"
              >
                <el-button
                  size="small"
                  type="primary"
                  plain
                  @click="selectAllCurrentPageTitles"
                  :disabled="!productTitles.length"
                >
                  å…¨é€‰å½“å‰é¡µ
                </el-button>
                <el-button
                  size="small"
                  type="success"
                  plain
                  @click="selectAllTitles()"
                  :disabled="!productTitles.length"
                >
                  å…¨é€‰å…¨éƒ¨
                </el-button>
              </div>
              <div>
                <el-button size="small" @click="batchSetCategory"
                  >æ‰¹é‡ç¼–è¾‘åˆ†ç±»</el-button
                >
                <el-button size="small" type="danger" @click="batchDeleteTitles"
                  >æ‰¹é‡åˆ é™¤</el-button
                >
                <!-- <el-button
                size="small"
                type="primary"
                @click="openOptimizeDialog"
                :disabled="!selectedRows.length"
              >
                æ‰¹é‡ä¼˜åŒ–æ ‡é¢˜
              </el-button> -->
                <el-button size="small" type="success" @click="exportTitleData"
                  >å¯¼å‡ºæ ‡é¢˜</el-button
                >
              </div>
            </el-col>
          </el-row>
        </template>

        <el-table
          :data="productPagedTitles"
          border
          @selection-change="handleSelectionChange"
          :row-key="(row: any) => row.title"
          ref="titleTableRef"
        >
          ref="titleTableRef" >
          <el-table-column type="selection" width="50" />
          <el-table-column prop="id" label="id" width="50">
            <template #default="{ row }"> {{ row.id + 1 }} </template>
          </el-table-column>
          <el-table-column prop="category" label="ç±»ç›®åç§°" width="180">
            <template #default="{ row }">
              <el-select
                v-model="row.category.id"
                placeholder="é€‰æ‹©ç±»ç›®"
                size="small"
                @change="
                  (val) => {
                    const selectedCat = categoryOptions.find(
                      (c) => c.id === val
                    );
                    row.category.name = selectedCat ? selectedCat.name : '';
                  }
                "
              >
                <el-option
                  v-for="cat in categoryOptions"
                  :key="cat.id"
                  :label="`${cat.name} (${cat.id})`"
                  :value="cat.id"
                />
              </el-select>
            </template>
          </el-table-column>
          <el-table-column label="æ ‡é¢˜é¢„è§ˆ" show-overflow-tooltip>
            <template #default="{ row }">
              <span>{{ row.title }}</span>
            </template>
          </el-table-column>
          <el-table-column label="æ“ä½œ" width="150">
            <template #default="{ row, $index }">
              <el-button size="small" type="primary" @click="editTitle(row)"
                >ç¼–è¾‘</el-button
              >
              <el-button
                size="small"
                type="danger"
                @click="productTitles.splice($index, 1)"
                >åˆ é™¤</el-button
              >
            </template>
          </el-table-column>
        </el-table>

        <div
          class="table-footer text-right mt-3"
          style="display: flex; margin-top: 15px"
        >
          <el-pagination
            v-model:current-page="currentPage"
            :page-size="pageSize"
            layout="prev, pager, next, total"
            :total="productTitles.length"
          />
        </div>
      </el-card>
    </div>
  </div>
  <el-dialog
    v-model="batchCategoryDialogVisible"
    title="æ‰¹é‡è®¾ç½®åˆ†ç±»"
    width="400px"
    align-center
  >
    <el-form label-width="80px">
      <el-form-item label="é€‰æ‹©ç±»ç›®">
        <el-select
          v-model="batchSelectedCategory"
          placeholder="è¯·é€‰æ‹©ç±»ç›®"
          style="width: 100%"
        >
          <!-- ä¿®æ”¹é€‰é¡¹æ˜¾ç¤ºæ–¹å¼ -->
          <el-option
            v-for="cat in categoryOptions"
            :key="cat.id"
            :label="`${cat.name} (${cat.id})`"
            :value="cat"
          />
        </el-select>
      </el-form-item>
    </el-form>

    <template #footer>
      <el-button @click="batchCategoryDialogVisible = false">å–æ¶ˆ</el-button>
      <el-button type="primary" @click="confirmBatchCategory">ç¡®è®¤</el-button>
    </template>
  </el-dialog>
  <!-- ğŸ“¥ æ–°å¢/ç¼–è¾‘è¯åº“å¼¹çª— -->
  <el-dialog
    v-model="dialogVisible"
    :title="dialogMode === 'edit' ? 'ç¼–è¾‘è¯åº“' : 'æ–°å¢è¯åº“'"
    width="800px"
  >
    <el-row style="margin-bottom: 10px">
      <el-col :span="8">
        <el-form-item label="è¯åº“åç§°" style="margin-bottom: 0">
          <el-input
            size="small"
            v-model="newLibrary.name"
            placeholder="ä¾‹å¦‚ï¼šå–ç‚¹ã€å“ç±»ã€ä½¿ç”¨åœºæ™¯"
          />
        </el-form-item>
      </el-col>
      <el-col
        :span="3"
        style="display: flex; align-items: center; margin-left: auto"
      >
        <el-button
          size="small"
          type="primary"
          @click="addKeywordRow"
          style="margin-left: 10px"
          >æ–°å¢å…³é”®è¯</el-button
        >
      </el-col>
    </el-row>
    <el-table :data="(newLibrary as any).words" border height="200">
      <el-table-column prop="zh" label="ä¸­æ–‡å…³é”®è¯" align="center">
        <template #default="{ row }">
          <el-input v-model="row.zh" placeholder="ä¸­æ–‡" />
        </template>
      </el-table-column>
      <el-table-column prop="en" label="è‹±æ–‡å…³é”®è¯" align="center">
        <template #default="{ row }">
          <el-input v-model="row.en" placeholder="English" />
        </template>
      </el-table-column>
      <el-table-column label="æ“ä½œ" width="200" align="center">
        <template #default="scope">
          <el-button
            type="primary"
            size="small"
            @click="newLibrary.words.splice(scope.$index, 1)"
          >
            <el-icon><Edit /></el-icon
          ></el-button>
          <el-button
            type="danger"
            size="small"
            @click="newLibrary.words.splice(scope.$index, 1)"
          >
            <el-icon><Delete /></el-icon
          ></el-button>
        </template>
      </el-table-column>
    </el-table>

    <template #footer>
      <el-button @click="dialogVisible = false">å–æ¶ˆ</el-button>
      <el-button type="primary" @click="confirmLibrary">ç¡®å®š</el-button>
    </template>
  </el-dialog>
  <el-dialog
    v-model="autoGenerateDialogVisible"
    title="AI ç”Ÿæˆè¯åº“"
    width="500px"
  >
    <el-form label-width="100px">
      <el-form-item label="AIæ¨¡å‹">
        <el-select
          v-model="selectedAiType"
          placeholder="è¯·é€‰æ‹©AIæ¨¡å‹"
          style="width: 100%"
        >
          <el-option label="é€šä¹‰åƒé—®(å…è´¹)" :value="'Qwen'" />
          <!-- <el-option label="openAI(æ”¶è´¹æ¥å£ï¼ŒæœåŠ¡ä¸ç¨³å®š)" value="openai" /> -->
        </el-select>
      </el-form-item>
      <el-form-item label="äº§å“åç§°">
        <el-input v-model="productName" placeholder="è¯·è¾“å…¥äº§å“åç§°" />
      </el-form-item>
      <el-form-item label="äº§å“å›¾ç‰‡">
        <el-upload
          :show-file-list="false"
          :auto-upload="false"
          accept="image/*"
          :before-upload="
            (file: any) => {
              selectedImageFile = file;
              return false;
            }
          "
        >
          <el-button>ä¸Šä¼ å›¾ç‰‡</el-button>
        </el-upload>
        <div
          v-if="selectedImageFile"
          style="margin-top: 8px; font-size: 12px; color: #999"
        >
          å½“å‰å·²é€‰ï¼š{{ selectedImageFile.name }}
        </div>
      </el-form-item>
      <el-form-item label="è¡¥å……è¯´æ˜">
        <el-input
          type="textarea"
          v-model="productSupplement"
          placeholder="ï¼ˆå¯é€‰ï¼‰æä¾›é¢å¤–è¯´æ˜ã€ææ–™ã€ç”¨é€”ç­‰æœ‰åŠ©äºæå‡ç”Ÿæˆè´¨é‡"
          rows="3"
        />
      </el-form-item>
    </el-form>

    <template #footer>
      <el-button
        @click="
          () => {
            autoGenerateDialogVisible = false;
            aiWordLibLoading = false;
          }
        "
        >å–æ¶ˆ</el-button
      >
      <el-button
        type="primary"
        :loading="aiWordLibLoading"
        @click="autoGenerateLibraries"
        >ç«‹å³ç”Ÿæˆ</el-button
      >
    </template>
  </el-dialog>
  <el-dialog v-model="optimizeDialogVisible" title="æ‰¹é‡ä¼˜åŒ–æ ‡é¢˜" width="500px">
    <el-form label-width="100px">
      <el-form-item label="æ’é™¤ä¼˜åŒ–è¯åº“">
        <el-select
          v-model="excludedLibraries"
          multiple
          placeholder="è¯·é€‰æ‹©è¦æ’é™¤çš„è¯åº“"
          style="width: 100%"
        >
          <el-option
            v-for="lib in wordLibraries"
            :key="lib.id"
            :label="lib.name"
            :value="lib.id"
          />
        </el-select>
      </el-form-item>
      <el-form-item label="è¿½åŠ ä½ç½®">
        <el-radio-group v-model="appendPosition">
          <el-radio label="before">æ ‡é¢˜å‰</el-radio>
          <el-radio label="after">æ ‡é¢˜å°¾éƒ¨</el-radio>
        </el-radio-group>
      </el-form-item>
    </el-form>
    <template #footer>
      <el-button @click="optimizeDialogVisible = false">å–æ¶ˆ</el-button>
      <el-button type="primary" @click="startBatchOptimize">å¼€å§‹ä¼˜åŒ–</el-button>
    </template>
  </el-dialog>
</template>

<style lang="scss" scoped>
.titlePage {
  height: 100vh;
  overflow-y: auto;
  .title-generator {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    padding-bottom: 100px;
  }
  .mb-1 {
    margin-bottom: 5px;
  }
  .mr-1 {
    margin-right: 5px;
  }
  .mt-4 {
    margin-top: 20px;
  }
  .applyRule {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    font-size: 14px;
  }
  .config-row {
    padding: 10px 0;
    border-bottom: 1px dashed #e4e7ed;
    margin-bottom: 5px;
  }
  .table-footer {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    margin-top: 15px;
  }
}
</style>

<script setup lang="ts">
import { ref, reactive, computed, onMounted, h, nextTick, watch } from "vue";
import { ElMessage, ElMessageBox, ElNotification } from "element-plus";
import {
  Edit,
  Delete,
  Plus,
  MagicStick,
  Connection,
  // @ts-ignore å¿½ç•¥ç±»å‹æ£€æŸ¥,å› ä¸ºVueå•æ–‡ä»¶ç»„ä»¶æ²¡æœ‰ç±»å‹å®šä¹‰
} from "@element-plus/icons-vue";
import * as XLSX from "xlsx";

// é¡¹ç›®ä¿¡æ¯
const projectList = ref<any[]>([]);
const selectedProject = ref("");
const productTitles = ref<any[]>([]);
const selectedRows = ref<any[]>([]);
const currentPage = ref(1);
const pageSize = ref(10);

// è¯åº“ç›¸å…³
const wordLibraries = ref<any[]>([]);
const idCounter = ref(0);
const titleCombineConfig = ref<{ libId: number; field: "zh" | "en" }[]>([]);
const generateCount = ref(20);
const generatedTitles = ref<string[]>([]);
const categoryOptions = ref<Array<{ id: string; name: string }>>([]);
const selectedAiType = ref("Qwen");
const aiWordLibLoading = ref(false);
const productSupplement = ref("");
const selectedLibRows = ref<any[]>([]);
const keywordJoiner = ref(" ");
// åº”ç”¨è§„åˆ™
const applyRule = ref("è½®å¾ªæ¨¡å¼");
// å¼¹çª—çŠ¶æ€
const dialogVisible = ref(false);
const dialogMode = ref<"add" | "edit">("add");
const newLibrary = ref({
  id: -1,
  name: "",
  words: [
    {
      zh: "",
      en: "",
    },
  ],
});
const productName = ref("");
const selectedImageFile = ref<File | null>(null);
const autoGenerateDialogVisible = ref(false);
const batchCategoryDialogVisible = ref(false);
const batchSelectedCategory = ref<{ id: string; name: string } | null>(null);
// æ‰¹é‡ä¼˜åŒ–ç›¸å…³çŠ¶æ€
const optimizeDialogVisible = ref(false); // ä¼˜åŒ–å¼¹çª—æ˜¯å¦å¯è§
const excludedLibraries = ref<number[]>([]); // æ’é™¤çš„è¯åº“ID
const appendPosition = ref<"before" | "after">("after"); // è¿½åŠ ä½ç½®
const isOptimizing = ref(false); // æ˜¯å¦æ­£åœ¨ä¼˜åŒ–
const optimizationLoadingText = ref("æ­£åœ¨ä¼˜åŒ–æ ‡é¢˜ï¼Œè¯·ç¨å€™..."); // åŠ è½½æç¤ºæ–‡æœ¬

// åˆ†é¡µæ˜¾ç¤º
const productPagedTitles = computed(() => {
  const start = (currentPage.value - 1) * pageSize.value;
  const end = start + pageSize.value;
  return productTitles.value.slice(start, end).map((t) => ({
    ...t,
    categoryDisplay: t.category ? `${t.category.name} (${t.category.id})` : "",
  }));
});
const selectedTitleSet = ref<Set<string>>(new Set());
const allSelectedRows = ref<any[]>([]);
const titleTableRef = ref(); // è·å–è¡¨æ ¼å®ä¾‹

// æ‰“å¼€ä¼˜åŒ–å¼¹çª—
function openOptimizeDialog() {
  optimizeDialogVisible.value = true;
}

// å¼€å§‹æ‰¹é‡ä¼˜åŒ–
async function startBatchOptimize() {
  if (selectedRows.value.length === 0) {
    ElMessage.warning("è¯·é€‰æ‹©è¦ä¼˜åŒ–çš„æ ‡é¢˜");
    return;
  }
  console.log(selectedRows.value);
  // é™åˆ¶ä¸€æ¬¡æœ€å¤š10ä¸ªæ ‡é¢˜
  const titlesToOptimize = selectedRows.value.map((row) => row.title);
  const excludedWords = excludedLibraries.value
    .map((libId) => {
      const lib = wordLibraries.value.find((l) => l.id === libId);
      return lib?.words.map((w: { zh: any; en: any }) => w.zh || w.en) || [];
    })
    .flat();

  // æ˜¾ç¤ºå…¨å±åŠ è½½çŠ¶æ€
  isOptimizing.value = true;
  optimizationLoadingText.value = `æ­£åœ¨ä¼˜åŒ–æ ‡é¢˜ï¼Œè¯·ç¨å€™...`;

  try {
    // å¾ªç¯è¯·æ±‚æ¯åä¸ªæ ‡é¢˜
    const chunkSize = 10;
    for (let i = 0; i < titlesToOptimize.length; i += chunkSize) {
      const chunk = titlesToOptimize.slice(i, i + chunkSize);
      const res = await fetch("http://localhost:3100/optimize-titles", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          titles: chunk,
          aiType: "Qwen",
        }),
      });

      const { success, data } = await res.json();
      if (!success) throw new Error("ä¼˜åŒ–å¤±è´¥");

      // æ›´æ–°è¡¨æ ¼æ•°æ®
      data.forEach((optimizedTitle: string, index: number) => {
        const row = selectedRows.value[i + index];
        if (row) row.title = optimizedTitle;
      });

      // æç¤ºç”¨æˆ·å½“å‰è¿›åº¦
      ElMessage.success(
        `å·²ä¼˜åŒ– ${Math.min(chunk.length, titlesToOptimize.length - i)} ä¸ªæ ‡é¢˜`
      );
    }

    ElMessage.success("æ‰€æœ‰æ ‡é¢˜ä¼˜åŒ–å®Œæˆ");
  } catch (err) {
    console.error("ä¼˜åŒ–å¤±è´¥", err);
    ElMessage.error("ä¼˜åŒ–å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•");
  } finally {
    // éšè—åŠ è½½çŠ¶æ€å¹¶å…³é—­å¼¹çª—
    isOptimizing.value = false;
    optimizeDialogVisible.value = false;
  }
}

// æ ‡é¢˜åˆ†é¡µç›¸å…³
function applyToCategory(event: any, newSize: number) {
  console.log("æ¯é¡µæ˜¾ç¤ºæ•°æ®é‡:", newSize);

  pageSize.value = newSize;
  currentPage.value = 1;

  const categories = categoryOptions.value;
  const titles = productTitles.value;

  const categoryCount = categories.length;
  const titlesCount = titles.length;

  console.log("ç±»ç›®æ•°é‡:", categoryCount, "æ ‡é¢˜æ•°é‡:", titlesCount);

  if (categoryCount === 0) {
    ElMessage.warning("è¯·å…ˆé€‰æ‹©ç±»ç›®");
    return;
  }

  // æ¸…é™¤æ‰€æœ‰å·²æœ‰åˆ†ç±»
  titles.forEach((title) => {
    title.category = null;
  });

  if (applyRule.value === "è½®å¾ªæ¨¡å¼") {
    const maxDivisible =
      Math.floor(titlesCount / categoryCount) * categoryCount;
    const remainingCount = titlesCount - maxDivisible;

    // è½®å¾ªåˆ†é…å®Œæ•´éƒ¨åˆ†
    for (let i = 0; i < maxDivisible; i++) {
      const categoryIndex = i % categoryCount;
      titles[i].category = {
        id: categories[categoryIndex].id,
        name: categories[categoryIndex].name,
      };
    }

    // å¤„ç†å‰©ä½™éƒ¨åˆ†
    if (remainingCount > 0) {
      const remainingTitles = titles.slice(maxDivisible);
      showRemainingDialog(remainingTitles, "è½®å¾ªæ¨¡å¼");
    } else {
      ElMessage.success("æ‰€æœ‰æ ‡é¢˜å·²å‡åŒ€åˆ†é…å®Œæˆ");
    }
  } else if (applyRule.value === "å‡åˆ†æ¨¡å¼") {
    const baseCount = Math.floor(titlesCount / categoryCount);
    const remainingCount = titlesCount - baseCount * categoryCount;

    let currentIndex = 0;

    // å‡åˆ†åŸºç¡€éƒ¨åˆ†
    for (let i = 0; i < categoryCount; i++) {
      for (let j = 0; j < baseCount; j++) {
        titles[currentIndex++].category = {
          id: categories[i].id,
          name: categories[i].name,
        };
      }
    }

    // å¤„ç†å‰©ä½™éƒ¨åˆ†
    if (remainingCount > 0) {
      const remainingTitles = titles.slice(currentIndex);
      showRemainingDialog(remainingTitles, "å‡åˆ†æ¨¡å¼");
    } else {
      ElMessage.success("æ‰€æœ‰æ ‡é¢˜å·²å‡åŒ€åˆ†é…å®Œæˆ");
    }
  }

  console.log("æ‰€æœ‰æ ‡é¢˜å·²åˆ†ç±»ç›®", titles);
}
function showRemainingDialog(remainingTitles: any[], mode: string) {
  const remainingCount = remainingTitles.length;
  const message =
    mode === "è½®å¾ªæ¨¡å¼"
      ? `è½®å¾ªæ¨¡å¼ä¸‹æœ‰${remainingCount}ä¸ªæ ‡é¢˜æ— æ³•å‡åŒ€åˆ†é…ï¼Œè¯·é€‰æ‹©å¤„ç†æ–¹å¼`
      : `å‡åˆ†æ¨¡å¼ä¸‹æœ‰${remainingCount}ä¸ªæ ‡é¢˜æ— æ³•å‡åŒ€åˆ†é…ï¼Œè¯·é€‰æ‹©å¤„ç†æ–¹å¼`;

  ElMessageBox.confirm(message, "å¤„ç†å‰©ä½™æ ‡é¢˜", {
    confirmButtonText:
      mode === "è½®å¾ªæ¨¡å¼" ? "ç»§ç»­è½®å¾ªåˆ†é…" : "è½®å¾ªåˆ†é…å‰©ä½™æ ‡é¢˜",
    cancelButtonText: "æ‰‹åŠ¨æŒ‡å®šç±»ç›®",
    distinguishCancelAndClose: true,
    type: "warning",
  })
    .then(() => {
      // ç»§ç»­è‡ªåŠ¨è½®å¾ªåˆ†é…
      remainingTitles.forEach((title, index) => {
        title.category =
          categoryOptions.value[index % categoryOptions.value.length];
      });
      ElMessage.success("æ‰€æœ‰æ ‡é¢˜å·²åˆ†é…å®Œæˆ");
    })
    .catch((action) => {
      if (action === "cancel") {
        selectedRows.value = remainingTitles;
        batchSetCategory(); // æ‰“å¼€æ‰¹é‡ç¼–è¾‘å¼¹çª—
      } else {
        ElMessage.info("å·²å–æ¶ˆåˆ†é…æ“ä½œ");
      }
    });
}
function handleSelectionChange(rows: any[]) {
  selectedRows.value = rows;
  const currentPageKeys = productPagedTitles.value.map((r) => r.title);
  currentPageKeys.forEach((key) => selectedTitleSet.value.delete(key)); // æ¸…é™¤å½“å‰é¡µæ—§é€‰ä¸­

  rows.forEach((r) => selectedTitleSet.value.add(r.title)); // æ·»åŠ æ–°é€‰ä¸­
}

function restoreSelection() {
  if (!titleTableRef.value) return;
  nextTick(() => {
    productPagedTitles.value.forEach((row) => {
      if (selectedTitleSet.value.has(row.title)) {
        titleTableRef.value!.toggleRowSelection(row, true);
      }
    });
  });
}

watch([currentPage, productTitles], restoreSelection);

function selectAllCurrentPageTitles() {
  if (!titleTableRef.value) return;

  const table = titleTableRef.value;
  const isAllSelected = productPagedTitles.value.every((row: any) =>
    selectedTitleSet.value.has(row.title)
  );

  productPagedTitles.value.forEach((row: any) => {
    const key = row.title;
    if (isAllSelected) {
      selectedTitleSet.value.delete(key);
      table.toggleRowSelection(row, false);
    } else {
      selectedTitleSet.value.add(key);
      table.toggleRowSelection(row, true);
    }
  });
}

// å·¥å…·å‡½æ•°
function parseWords(raw: string): string[] {
  return raw
    .replace(/ï¼Œ/g, ",")
    .replace(/\s+/g, ",")
    .replace(/,+/g, ",")
    .split(",")
    .map((w) => w.trim())
    .filter(Boolean);
}

function normalizeRawWords(raw: string): string {
  return raw
    .replace(/ï¼Œ/g, ",")
    .replace(/\s+/g, ",")
    .replace(/,+/g, ",")
    .trim();
}
async function saveLibrariesToFile() {
  const project = projectList.value.find(
    (p) => p.folderName === selectedProject.value
  );
  if (!project) return;

  const content = JSON.stringify(wordLibraries.value, null, 2);
  const targetPath = `${project.folderPath}\\è¯åº“.json`;

  try {
    await window.electronAPI.saveFileSilently(content, targetPath);
  } catch (err) {
    console.error("è¯åº“ä¿å­˜å¤±è´¥ï¼š", err);
    ElMessage.error("è¯åº“æ–‡ä»¶ä¿å­˜å¤±è´¥");
  }
}
// æ‰“å¼€æ–°å¢è¯åº“å¼¹çª—
function openAddDialog() {
  dialogMode.value = "add";
  newLibrary.value = {
    id: -1,
    name: "",
    words: [
      {
        zh: "",
        en: "",
      },
    ],
  };
  dialogVisible.value = true;
}
function addKeywordRow() {
  // åˆå§‹åŒ– words æ•°ç»„ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºç©ºæ•°ç»„
  (newLibrary.value as any).words = (newLibrary.value as any).words || [];
  (newLibrary.value as any).words.push({ zh: "", en: "" });
}

function editLibrary(row: any) {
  dialogMode.value = "edit";
  newLibrary.value = {
    id: row.id,
    name: row.name,
    words: row.words,
  };
  console.log(newLibrary.value);

  dialogVisible.value = true;
}

// ç¡®è®¤ä¿å­˜è¯åº“
function confirmLibrary() {
  const words = newLibrary.value.words.filter(
    (w) => w.zh.trim() || w.en.trim()
  );

  if (!newLibrary.value.name || words.length === 0) {
    ElMessage.warning("è¯åº“åç§°ä¸èƒ½ä¸ºç©ºï¼Œä¸”è‡³å°‘å¡«å†™ä¸€ä¸ªä¸­æˆ–è‹±æ–‡å…³é”®è¯");
    return;
  }

  const payload = {
    id: dialogMode.value === "edit" ? newLibrary.value.id : idCounter.value++,
    name: newLibrary.value.name.trim(),
    words: words.map((w) => ({
      zh: w.zh.trim(),
      en: w.en.trim(),
    })),
  };

  if (dialogMode.value === "edit") {
    const index = wordLibraries.value.findIndex((l) => l.id === payload.id);
    if (index !== -1) wordLibraries.value[index] = payload;
  } else {
    wordLibraries.value.push(payload);
  }

  saveLibrariesToFile(); // åŒæ­¥å†™å…¥JSONæ–‡ä»¶
  dialogVisible.value = false;
  ElMessage.success("è¯åº“å·²ä¿å­˜");

  // é‡ç½®è¡¨å•
  newLibrary.value = {
    id: -1,
    name: "",
    words: [{ zh: "", en: "" }],
  };
}

// åˆ é™¤è¯åº“
function removeLibrary(index: number) {
  wordLibraries.value.splice(index, 1);
  saveLibrariesToFile();
}

function batchDeleteLibraries() {
  if (!selectedLibRows.value.length) {
    ElMessage.warning("è¯·å…ˆé€‰æ‹©è¯åº“");
    return;
  }
  ElMessageBox.confirm("ç¡®è®¤åˆ é™¤é€‰ä¸­çš„è¯åº“å—ï¼Ÿ", "æ‰¹é‡åˆ é™¤", {
    type: "warning",
  }).then(() => {
    wordLibraries.value = wordLibraries.value.filter(
      (lib) => !selectedLibRows.value.includes(lib)
    );
    selectedLibRows.value = [];
    ElMessage.success("å·²åˆ é™¤æ‰€é€‰è¯åº“");
  });
}

// å¯¼å‡ºè¯åº“
function exportLibraries() {
  const project = projectList.value.find(
    (p) => p.folderName === selectedProject.value
  );
  if (!project) return;

  const content = JSON.stringify(wordLibraries.value, null, 2);
  const filename = "è¯åº“.json";
  const defaultPath = project.folderPath;

  window.electronAPI
    .saveFile(content, filename, defaultPath)
    .then(() => {
      ElMessage.success("è¯åº“å·²å¯¼å‡ºåˆ°é¡¹ç›®ç›®å½•");
    })
    .catch((err: any) => {
      console.error("å¯¼å‡ºå¤±è´¥:", err);
      ElMessage.error("è¯åº“å¯¼å‡ºå¤±è´¥");
    });
}

// å¯¼å…¥è¯åº“
function importLibraries(file: any) {
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const result = JSON.parse(reader.result as string);
      if (Array.isArray(result)) {
        result.forEach((item) => {
          item.id = idCounter.value++;
          if (!item.words && item.wordsRaw) {
            // å…¼å®¹æ—§ç»“æ„
            const words = parseWords(item.wordsRaw).map((w) => ({
              zh: w,
              en: w,
            }));
            item.words = words;
          }
        });
        wordLibraries.value.push(...result);
        ElMessage.success("è¯åº“å¯¼å…¥æˆåŠŸ");
      } else {
        throw new Error("æ ¼å¼é”™è¯¯");
      }
    } catch {
      ElMessage.error("è¯åº“å¯¼å…¥å¤±è´¥");
    }
  };
  reader.readAsText(file.raw);
}

// AIç”Ÿæˆè¯åº“ç›¸å…³
// è¯»å–æ–‡ä»¶ä¸ºbase64
function readFileAsBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve((reader.result as string).split(",")[1]);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}
// AIç”Ÿæˆè¯åº“
async function fetchWordLibraries(
  productName: string,
  imageFile?: File,
  aiType?: string,
  supplement?: string
) {
  let imageBase64 = "";
  if (imageFile) {
    imageBase64 = await readFileAsBase64(imageFile);
  }

  const res = await fetch("http://121.41.45.224:3100/generate-word-libraries", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      productName,
      image: imageBase64,
      aiType,
      supplement,
    }),
  });

  const { success, data: result } = await res.json();
  if (!success) {
    ElNotification.closeAll();
    ElMessage.error("ç”Ÿæˆå¤±è´¥");
  }
  ElNotification.closeAll();
  ElMessage.success("AIè¯åº“ç”ŸæˆæˆåŠŸï¼");
  return result;
}

// æ ¡éªŒæ•°æ®å¿…å¡«é¡¹
async function autoGenerateLibraries() {
  if (!productName.value) {
    ElMessage.warning("è¯·è¾“å…¥äº§å“åç§°");
    return;
  }

  aiWordLibLoading.value = true;
  ElNotification({
    title: "æ­£åœ¨ç”Ÿæˆè¯åº“",
    message: "AIæ­£åœ¨ç”Ÿæˆå…³é”®è¯è¯åº“ï¼Œé¢„è®¡éœ€è¦ 10~30 ç§’ï¼Œè¯·ç¨å€™...",
    type: "success",
    duration: 0, // æ°¸ä¸è‡ªåŠ¨å…³é—­ï¼Œç›´åˆ°æˆåŠŸæˆ–å¤±è´¥
  });

  try {
    const { data: libraries } = await fetchWordLibraries(
      productName.value,
      selectedImageFile.value || undefined,
      selectedAiType.value,
      productSupplement.value
    );
    console.log(libraries);

    const existingNames = wordLibraries.value.map((lib) => lib.name);
    const existingWordSet = new Set<string>();
    wordLibraries.value.forEach((lib) =>
      lib.words?.forEach((w: any) =>
        existingWordSet.add(`${w.zh}|${w.en}`.toLowerCase())
      )
    );

    let addedCount = 0;

    libraries.forEach((lib: any) => {
      const existingIndex = wordLibraries.value.findIndex(
        (item) => item.name === lib.name
      );

      const incomingWords = lib.words || [];

      if (existingIndex !== -1) {
        // å·²å­˜åœ¨åŒåè¯åº“ï¼Œåˆå¹¶å»é‡
        const existingWordSet = new Set(
          wordLibraries.value[existingIndex].words.map((w: any) =>
            `${w.zh}|${w.en}`.toLowerCase()
          )
        );

        const newWords = incomingWords.filter((w: any) => {
          const key = `${w.zh}|${w.en}`.toLowerCase();
          return !existingWordSet.has(key);
        });

        if (newWords.length > 0) {
          wordLibraries.value[existingIndex].words.push(...newWords);
          console.log(
            `[åˆå¹¶] ${lib.name} æ·»åŠ äº† ${newWords.length} ä¸ªæ–°å…³é”®è¯`
          );
        } else {
          console.log(`[å¿½ç•¥] ${lib.name} ä¸­æ— æ–°å¢å…³é”®è¯`);
        }
      } else {
        // ä¸å­˜åœ¨è¯¥åç§°ï¼Œç›´æ¥æ–°å¢
        wordLibraries.value.push({
          id: idCounter.value++,
          name: lib.name,
          words: incomingWords,
        });
        console.log(`[æ–°å¢] æ·»åŠ æ–°è¯åº“ï¼š${lib.name}`);
      }
    });

    if (addedCount === 0) {
      ElMessage.warning("æ²¡æœ‰æ–°çš„è¯åº“è¢«æ·»åŠ ï¼ˆå¯èƒ½ä¸ç°æœ‰é‡å¤ï¼‰");
    } else {
      ElMessage.success(`æˆåŠŸç”Ÿæˆå¹¶æ·»åŠ  ${addedCount} ä¸ªæ–°è¯åº“ï¼`);
    }

    // ä¿å­˜
    const project = projectList.value.find(
      (p) => p.folderName === selectedProject.value
    );
    if (project) {
      const content = JSON.stringify(wordLibraries.value, null, 2);
      await window.electronAPI.saveFileSilently(
        content,
        project.folderPath + "\\è¯åº“.json"
      );
    }

    autoGenerateDialogVisible.value = false;
    selectedImageFile.value = null;
    productSupplement.value = "";
    productName.value = "";
  } catch (err: any) {
    console.error("[AIç”Ÿæˆè¯åº“å¤±è´¥]", err);
    ElMessage.error("ç”Ÿæˆå¤±è´¥ï¼š" + err.message);
  } finally {
    aiWordLibLoading.value = false;
  }
}

function generateTitles() {
  const pools: string[][] = [];

  for (const config of titleCombineConfig.value) {
    const lib = wordLibraries.value.find((l) => l.id === config.libId);
    if (!lib || !lib.words?.length) continue;

    const words = lib.words
      .map((w: any) => w[config.field]?.trim())
      .filter(Boolean);
    if (words.length === 0) continue;

    pools.push(words);
  }

  const totalPossible = pools.reduce((acc, arr) => acc * arr.length, 1);
  if (totalPossible < generateCount.value) {
    ElMessage.warning(
      `æœ€å¤šå¯ç”Ÿæˆ ${totalPossible} æ¡ï¼Œå½“å‰è®¾ç½®ä¸º ${generateCount.value} æ¡ï¼Œè¯·è°ƒæ•´`
    );
    return;
  }

  const set = new Set<string>();
  const tryLimit = generateCount.value * 10;
  let tries = 0;

  while (set.size < generateCount.value && tries++ < tryLimit) {
    const picked = pools.map(
      (arr) => arr[Math.floor(Math.random() * arr.length)]
    );
    const unique = [...new Set(picked)];

    if (unique.length === picked.length) {
      const title = unique.join(keywordJoiner.value);
      set.add(title);
    }
  }

  if (set.size < generateCount.value) {
    ElMessage.warning(`ä»…æˆåŠŸç”Ÿæˆ ${set.size} æ¡å”¯ä¸€æ ‡é¢˜ï¼ˆå·²æ’é™¤é‡å¤è¯ï¼‰`);
  } else {
    ElMessage.success("æ ‡é¢˜ç”ŸæˆæˆåŠŸ");
  }

  const category = categoryOptions.value[0] || "";
  const newTitles = Array.from(set).map((t) => ({
    id: idCounter.value++,
    title: t,
    category,
  }));
  newTitles.forEach((t, n) => {
    t.id = productTitles.value.length + n;
  });
  productTitles.value.push(...newTitles);
}

// æ‰“å¼€æ‰¹é‡è®¾ç½®åˆ†ç±»å¼¹çª—
function batchSetCategory() {
  if (selectedRows.value.length === 0) {
    ElMessage.warning("è¯·å…ˆé€‰æ‹©æ ‡é¢˜");
    return;
  }

  // è®¾ç½®é»˜è®¤é€‰ä¸­çš„åˆ†ç±»ï¼ˆç¬¬ä¸€ä¸ªæœ‰æ•ˆåˆ†ç±»æˆ–ç©ºï¼‰
  batchSelectedCategory.value =
    categoryOptions.value.length > 0 ? categoryOptions.value[0] : null;

  batchCategoryDialogVisible.value = true;
}
function selectAllTitles() {
  const isAllSelected = productTitles.value.every((row) =>
    allSelectedRows.value.includes(row.title)
  );

  if (isAllSelected) {
    // å–æ¶ˆå…¨é€‰
    allSelectedRows.value = [];
  } else {
    // å‹¾é€‰å…¨éƒ¨
    allSelectedRows.value = productTitles.value.map((row) => row.title);
  }

  // æ›´æ–°è¡¨æ ¼çš„é€‰æ‹©çŠ¶æ€
  nextTick(() => {
    productPagedTitles.value.forEach((row: any) => {
      titleTableRef.value!.toggleRowSelection(
        row,
        allSelectedRows.value.includes(row.title)
      );
    });
  });
}

// åˆ†é¡µå˜åŒ–æˆ–åˆ·æ–°æ—¶ï¼Œæ¢å¤é€‰ä¸­çŠ¶æ€
watch(productPagedTitles, () => {
  if (!titleTableRef.value) return;
  nextTick(() => {
    productPagedTitles.value.forEach((row: any) => {
      titleTableRef.value!.toggleRowSelection(
        row,
        allSelectedRows.value.includes(row)
      );
    });
  });
});
// ç¡®è®¤æ‰¹é‡è®¾ç½®åˆ†ç±»
function confirmBatchCategory() {
  if (!batchSelectedCategory.value) {
    ElMessage.warning("è¯·å…ˆé€‰æ‹©è¦è®¾ç½®çš„åˆ†ç±»");
    return;
  }

  selectedRows.value.forEach((row) => {
    // å­˜å‚¨å®Œæ•´çš„åˆ†ç±»å¯¹è±¡
    row.category = {
      id: batchSelectedCategory.value!.id,
      name: batchSelectedCategory.value!.name,
    };
  });

  ElMessage.success("åˆ†ç±»è®¾ç½®æˆåŠŸ");
  batchCategoryDialogVisible.value = false;
}

// åˆ é™¤æ‰€é€‰æ ‡é¢˜
function batchDeleteTitles() {
  if (!selectedRows.value.length && !allSelectedRows.value.length) {
    ElMessage.warning("è¯·é€‰æ‹©è¦åˆ é™¤çš„æ ‡é¢˜");
    return;
  }
  if (allSelectedRows.value.length > 0) {
    return ElMessageBox.confirm(
      `ç¡®å®šè¦åˆ é™¤æ‰€é€‰ ${selectedRows.value.length} ä¸ªæ ‡é¢˜å—ï¼Ÿ`
    )
      .then((res) => {
        if (res == "confirm") {
          // è¿‡æ»¤æ‰è¢«é€‰ä¸­çš„æ ‡é¢˜
          productTitles.value = productTitles.value.filter(
            (t) => !allSelectedRows.value.includes(t.title)
          );
          // æ¸…ç©ºå·²é€‰ä¸­çš„è®°å½•
          allSelectedRows.value = [];
          return ElMessage.success("å·²åˆ é™¤æ‰€é€‰æ ‡é¢˜");
        }
      })
      .catch(() => {
        return ElMessage({
          type: "info",
          message: "å·²å–æ¶ˆåˆ é™¤",
        });
      });
  }
  if (selectedRows.value.length > 0) {
    return ElMessageBox.confirm(
      `ç¡®å®šè¦åˆ é™¤æ‰€é€‰ ${selectedRows.value.length} ä¸ªæ ‡é¢˜å—ï¼Ÿ`
    )
      .then((res) => {
        if (res == "confirm") {
          // è¿‡æ»¤æ‰è¢«é€‰ä¸­çš„æ ‡é¢˜
          productTitles.value = productTitles.value.filter((titleRow) => {
            // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦ä¸åœ¨é€‰ä¸­è¡Œä¸­
            return !selectedRows.value.some(
              (t: any) => titleRow.title === t.title
            );
          });

          // æ¸…ç©ºå·²é€‰ä¸­çš„è®°å½•
          selectedRows.value = [];
          return ElMessage.success("å·²åˆ é™¤æ‰€é€‰æ ‡é¢˜");
        }
      })
      .catch(() => {
        return ElMessage({
          type: "info",
          message: "å·²å–æ¶ˆåˆ é™¤",
        });
      });
  }
}

function editTitle(row: any) {
  ElMessageBox.prompt("ä¿®æ”¹æ ‡é¢˜", {
    inputValue: row.title,
    confirmButtonText: "ç¡®å®š",
    cancelButtonText: "å–æ¶ˆ",
  }).then(({ value }) => {
    row.title = value;
    ElMessage.success("ä¿®æ”¹æˆåŠŸ");
  });
}

async function exportTitleData() {
  const project = projectList.value.find(
    (p) => p.folderName === selectedProject.value
  );
  if (!project) return;

  const rows = productTitles.value.map((item) => ({
    äº§å“æ ‡é¢˜: item.title,
    åˆ†ç±»id: item.category?.id || "",
  }));

  const worksheet = XLSX.utils.json_to_sheet(rows, {
    header: ["åˆ†ç±»id", "äº§å“æ ‡é¢˜"],
  });
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");

  const wbout = XLSX.write(workbook, {
    bookType: "xlsx",
    type: "array",
  });

  await window.electronAPI.saveFile(wbout, "äº§å“æ ‡é¢˜.xlsx", project.folderPath);

  ElMessage.success("æ ‡é¢˜æ•°æ®å·²å¯¼å‡º");
}

// é¡¹ç›®åˆ‡æ¢æ—¶åŠ è½½ Excel æ•°æ®
async function handleProjectChange() {
  const project = projectList.value.find(
    (p) => p.folderName === selectedProject.value
  );
  if (!project) return;

  const titlePath = `${project.folderPath}\\äº§å“æ ‡é¢˜.xlsx`;
  const categoryPath = `${project.folderPath}\\ç±»ç›®æ•°æ®.xlsx`;
  const wordLibPath = `${project.folderPath}\\è¯åº“.json`;

  await window.electronAPI.readExcel(categoryPath).then((rows: any[]) => {
    const uniqueCategories = new Map();
    rows.forEach((r) => {
      const key = `${r.åˆ†ç±»id}_${r.ç±»ç›®åç§°}`;
      if (!uniqueCategories.has(key)) {
        uniqueCategories.set(key, {
          id: r.åˆ†ç±»id,
          name: r.ç±»ç›®åç§°,
        });
      }
    });
    categoryOptions.value = Array.from(uniqueCategories.values());
  });
  // è¯»å–æ ‡é¢˜æ•°æ®æ—¶ä¿æŒåˆ†ç±»ä¿¡æ¯
  await window.electronAPI.readExcel(titlePath).then((rows: any[]) => {
    productTitles.value = rows.map((r: any, id: number) => ({
      id,
      title: r.äº§å“æ ‡é¢˜ || "",
      category: {
        id: r.åˆ†ç±»id || "",
        name:
          categoryOptions.value.find((c) => c.id === (r.åˆ†ç±»id || ""))?.name ||
          "",
      },
    }));
  });
  console.log(productTitles.value);

  // åˆå§‹åŒ–è¯»å–è¯åº“
  // 1. æ£€æŸ¥è¯åº“æ–‡ä»¶æ˜¯å¦å­˜åœ¨
  const existWordLib = await window.electronAPI.checkFileExists(wordLibPath);
  if (existWordLib) {
    // 2. å¦‚æœå­˜åœ¨ï¼Œè¯»å–å¹¶è§£æä¸º JSON
    await window.electronAPI
      .readFile(wordLibPath)
      .then((buf: AllowSharedBufferSource | undefined) => {
        try {
          const json = JSON.parse(new TextDecoder().decode(buf));
          if (Array.isArray(json)) {
            wordLibraries.value = json.map((item) => ({
              ...item,
              id: idCounter.value++,
            }));
            console.log(wordLibraries.value);

            ElMessage.success("å·²åŠ è½½é¡¹ç›®è¯åº“");
          }
        } catch (err) {
          console.warn("è¯åº“æ–‡ä»¶è¯»å–å¤±è´¥æˆ–æ ¼å¼é”™è¯¯ï¼š", err);
        }
      })
      .catch(() => {
        console.info("æœªæ£€æµ‹åˆ°è¯åº“æ–‡ä»¶");
      });
  }
}

// åˆå§‹åŒ–
onMounted(async () => {
  try {
    const data = await window.electronAPI.loadProjectList();
    projectList.value = JSON.parse(data);
    if (projectList.value.length > 0) {
      selectedProject.value = projectList.value[0].folderName;
      handleProjectChange();
    }
  } catch (e) {
    ElMessage.error("åŠ è½½é¡¹ç›®å¤±è´¥");
  }
});
</script>
